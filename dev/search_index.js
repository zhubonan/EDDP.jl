var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Documentation for the functions included in the package.","category":"page"},{"location":"functions/#Feature-Generation","page":"Functions","title":"Feature Generation","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function and types for generating features ","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"feature.jl\",\n    \"gradient.jl\",\n    \"embedding.jl\",\n    \"embedding_rules.jl\",\n    \"repulsive_core.jl\",\n]","category":"page"},{"location":"functions/#EDDP.CellFeature","page":"Functions","title":"EDDP.CellFeature","text":"CellFeature\n\nCollection of Feature specifications and cell.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.CellFeature-Tuple{Any}","page":"Functions","title":"EDDP.CellFeature","text":"CellFeature(elements;kwargs...)\n\nConstruct a CellFeature instance.\n\nArgs\n\nelements: A vector of the elements to be included in the features.\np2: A sequence of the two-body polynomial powers (p).\np3: A sequence of the three-body polynomial powers (p).\nq3: A sequence of the three-body polynomial powers (q).\nrcut2: Cut off distance for two-body features.\nrcut3: Cut off distance for three-body features.\nf2: Distance function for two-body interactions.\nf3: Distance function for three-body interactions.\ng2: Gradient function for two-body interactions.\ng3: Gradient function for three-body interactions.\ngeometry_sequence: Wether to covnert the p2, p3, q3 as geometry sequence.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.ThreeBodyFeature","page":"Functions","title":"EDDP.ThreeBodyFeature","text":"(f::ThreeBodyFeature)(out::Vector, rij, rik, rjk, si, sj, sk)\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.ThreeBodyFeature-2","page":"Functions","title":"EDDP.ThreeBodyFeature","text":"(f::ThreeBodyFeature)(out::Vector, rij, rik, rjk)\n\nAccumulate an existing feature vector\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.ThreeBodyFeature-3","page":"Functions","title":"EDDP.ThreeBodyFeature","text":"ThreeBodyFeature{T, M} <: AbstractNBodyFeature\n\nType for constructing the feature vector of the three-body interactions.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.ThreeBodyFeature-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.ThreeBodyFeature","text":"(f::ThreeBodyFeature)(rij) = f(zeros(nfeatures(f)), rij, rik, rjk)\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.TwoBodyFeature","page":"Functions","title":"EDDP.TwoBodyFeature","text":"(f::TwoBodyFeature)(out::AbstractMatrix, rij, iat, istart=1)\n\nAccumulate an existing matrix of the feature vectors\n\nArgs:\n\nout: Output matrix\nrji: distance between two atoms\niat: starting index of the vector to be updated\nistart: starting index of the vector to be updated\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.TwoBodyFeature-2","page":"Functions","title":"EDDP.TwoBodyFeature","text":"TwoBodyFeature{T, M} <: AbstractNBodyFeature\n\nType for constructing the feature vector of the two-body interactions.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.:+-Tuple{CellFeature, CellFeature}","page":"Functions","title":"Base.:+","text":"+(a::CellFeature, b::CellFeature)\n\nCombine two CellFeature objects together. The features are simply concatenated in this case.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:Union{EDDP.AbstractNBodyFeature, CellFeature}","page":"Functions","title":"Base.:==","text":"==(A::T, B::T) where {T<:Union{AbstractNBodyFeature, CellFeature}}\n\nCheck equality between two CellFeature / AbstractNBodyFeature objects.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.fast_pow-Tuple{Any, Int64}","page":"Functions","title":"EDDP.fast_pow","text":"Faster version of (^) by expanding more integer power into multiplications\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_names-Tuple","page":"Functions","title":"EDDP.feature_names","text":"feature_names(features...)\n\nReturn the name for the features.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_names-Tuple{CellFeature}","page":"Functions","title":"EDDP.feature_names","text":"feature_names(cf::CellFeature)\n\nReturn the name for the features.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_size-Tuple{CellFeature}","page":"Functions","title":"EDDP.feature_size","text":"feature_size(cf::CellFeature)\n\nReturn size of the feature vector for each body-order of a CellFeature object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_vector!-Tuple{Any, Tuple, Tuple, Cell}","page":"Functions","title":"EDDP.feature_vector!","text":"feature_vector!(fvecs, gvecs, features2, features3, cell;kwargs...)\n\nArgs:\n\nnl: If passed, using it as an existing NeighbourList.\n\nCompute the feature vector for a given set of two and three body interactions,  This is an optimised version for feature generation, but does not compute the gradients.\n\nReturns the feature vector and the core repulsion energy if any.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_vector-Tuple{CellFeature, Cell}","page":"Functions","title":"EDDP.feature_vector","text":"feature_vector(cf::CellFeature, cell::Cell; nmax=500, skin=1.0)\n\nReturn a matrix of vectors describing the environment of each atom.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_vector2!-Tuple{Any, Tuple, Cell}","page":"Functions","title":"EDDP.feature_vector2!","text":"feature_vector(features::Vector{T}, cell::Cell) where T\n\nCompute the feature vector for a give set of two body interactions\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.feature_vector3!-Tuple{Any, Tuple, Cell}","page":"Functions","title":"EDDP.feature_vector3!","text":"feature_vector(features::Vector{T}, cell::Cell) where T\n\nCompute the feature vector for each atom a give set of three body interactions\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.fr-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Functions","title":"EDDP.fr","text":"fr(r, rcut)\n\nEquation 7 in Pickard 2022 describing interactions with well-behaved cut offs:\n\nf(r)= begincases \n    2(1 - r  r_rc)  r leq r_rc  \n    0  r  r_rc \n    endcases\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.genp-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.genp","text":"Generate p/q as a geometry series\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.genp-Tuple{Union{StepRange, UnitRange}}","page":"Functions","title":"EDDP.genp","text":"Generate p/q as geometry series\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.gfr-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Functions","title":"EDDP.gfr","text":"gfr(r, rcut)\n\nGradient of the Equation 7 in Pickard 2022 describing interactions with well-behaved cut offs:\n\ng(r)= begincases \n    -2  r_rc  r leq r_rc  \n    0  r  r_rc \n    endcases\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.nbodyfeatures-Tuple{CellFeature, Any}","page":"Functions","title":"EDDP.nbodyfeatures","text":"nbodyfeatures(c::CellFeature, nbody)\n\nReturn the number of N-body features\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.nfeatures-Tuple{CellFeature}","page":"Functions","title":"EDDP.nfeatures","text":"features(c::CellFeature)\n\nReturn the total number of features elements in a CellFeature object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.one_body_vectors!-Tuple{AbstractMatrix, Cell, CellFeature}","page":"Functions","title":"EDDP.one_body_vectors!","text":"one_body_vectors!(v, cell::Cell, cf::CellFeature)\n\nConstruct one-body features for the structure. The one-body feature is essentially an one-hot encoding of the specie labels \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.one_body_vectors-Tuple{Cell, CellFeature}","page":"Functions","title":"EDDP.one_body_vectors","text":"one_body_vectors(cell::Cell, cf::CellFeature)\n\nConstruct one-body features for the structure. The one-body feature is essentially an one-hot encoding of the specie labels \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.permequal-NTuple{4, Any}","page":"Functions","title":"EDDP.permequal","text":"permequal(A, i, j, k)\n\nCheck equivalence considering all permutations with the first element matched.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.permequal-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.permequal","text":"permequal(A, i, j)\n\nCheck equivalence considering all permutations with the first element matched. \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.suggest_rcut-Tuple","page":"Functions","title":"EDDP.suggest_rcut","text":"suggest_rcut(features...; offset=1.0)\n\nGet a suggested rcut for a collection of features.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.suggest_rcut-Tuple{CellFeature}","page":"Functions","title":"EDDP.suggest_rcut","text":"suggest_rcut(cf::CellFeature; offset=1.0)\n\nGet a suggested cut off radius for NN list for a CellFeature.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.three_body_feature_from_mapping","page":"Functions","title":"EDDP.three_body_feature_from_mapping","text":"three_body_feature_from_mapping(cell::Cell, p_mapping, q_mapping, rcut, func=fr)\n\nConstruct a vector containing the TwoBodyFeatures\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.two_body_feature_from_mapping","page":"Functions","title":"EDDP.two_body_feature_from_mapping","text":"two_body_feature_from_mapping(cell::Cell, p_mapping, rcut, func=fr)\n\nConstruct a vector containing the TwoBodyFeatures\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.withgradient!-Tuple{Any, Any, EDDP.TwoBodyFeature, Any, Any, Any}","page":"Functions","title":"EDDP.withgradient!","text":"withgradient!(e::Matrix, g::Vector, f::TwoBodyFeature, rij, iat, istart)\n\nCalculate d(f(r)^p) / dr for each feature as well as the feature vector vector.\n\nArgs:\n\ne: The matrix storing the feature vectors of shape (nfe, nat)\ng: The matrix storing the gradient feature vectors of shape (nfe,), for this particular pair of i and j.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.withgradient!-Tuple{Matrix, Matrix, EDDP.ThreeBodyFeature, Any, Any, Any, Any, Any}","page":"Functions","title":"EDDP.withgradient!","text":"Calculate df / drij, df /drik, df/drjk for each element of a ThreeBodyFeature\n\nArgs:\n\ne: The matrix storing the feature vectors of shape (nfe, nat)\ng: The matrix storing the gradient feature vectors of shape (3, nfe), against rij, rik and rjk for this particular combination of i, j, k.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.ForceBuffer","page":"Functions","title":"EDDP.ForceBuffer","text":"ForceBuffer{T}\n\nBuffer for storing forces and stress and support their calculations\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.ForceBuffer-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Functions","title":"EDDP.ForceBuffer","text":"Initialise a buffer for computing forces\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._force_update!-Tuple{EDDP.ForceBuffer, Any, Any}","page":"Functions","title":"EDDP._force_update!","text":"_force_update!(buffer::Array{T, 2}, gv, g)\n\nPropagate chain rule to obtain the forces\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._stress_update!-Tuple{EDDP.ForceBuffer, Any}","page":"Functions","title":"EDDP._stress_update!","text":"_stress_update!(buffer::Array{T, 2}, sv, s) where {T}\n\nPropagate chain rule to obtain the stress\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.compute_fv!-Tuple{Any, Any, Any, Cell}","page":"Functions","title":"EDDP.compute_fv!","text":"compute_fv!(fvecs, features2, features3, cell;nl,\n\nCompute feature vectors only. \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.compute_fv_gv!-Tuple{EDDP.ForceBuffer, Any, Any, Cell}","page":"Functions","title":"EDDP.compute_fv_gv!","text":"compute_fv_gv!(fvecs, gvecs, features2, features3, cell::Cell;nl=NeighbourList(cell, features[1].rcut))\n\nCompute the feature vector for a given set of two and three body interactions, compute gradients as well. Optimised version with reduced computational cost....\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.BodyEmbedding","page":"Functions","title":"EDDP.BodyEmbedding","text":"Embedding for a specific body order\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.BodyEmbedding-Tuple{AbstractMatrix}","page":"Functions","title":"EDDP.BodyEmbedding","text":"Apply the embedding for an matrix input, the columns are made of vectors  to be embedded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.BodyEmbedding-Tuple{AbstractVector}","page":"Functions","title":"EDDP.BodyEmbedding","text":"Apply the embedding\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.BodyEmbeddingGradient","page":"Functions","title":"EDDP.BodyEmbeddingGradient","text":"Compute the gradient of the embedding layer       (W) x -> Embedding -> out\n\nThe embeding layer does is \n\nout = x W\n\nOperation is assumed to be in the \"batch\" mode, taking inputs of multiple columns\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.CellEmbedding","page":"Functions","title":"EDDP.CellEmbedding","text":"Embedding for a full CellFeature\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.CellEmbedding-Tuple{AbstractMatrix}","page":"Functions","title":"EDDP.CellEmbedding","text":"Apply CellEmbedding to a full feature vector\n\nThis is written in such way to support autograd...\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.CellEmbedding-Tuple{AbstractVector}","page":"Functions","title":"EDDP.CellEmbedding","text":"Apply CellEmbedding to a full feature vector\n\nThis is written in such way to support autograd...\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.CellEmbeddingGradient","page":"Functions","title":"EDDP.CellEmbeddingGradient","text":"Container to operate forward and backward passes\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP._apply_embedding-Tuple{AbstractMatrix, AbstractMatrix}","page":"Functions","title":"EDDP._apply_embedding","text":"Apply weighted averages to each column of a matrix, the weights are stored in a matrix as well.\n\nO = F W\n\nThis is simply right multiply the weight matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._apply_embedding_batch!-NTuple{4, Any}","page":"Functions","title":"EDDP._apply_embedding_batch!","text":"Apply the embedding for an matrix input, the columns are made of vectors  to be embedded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._apply_embedding_batch-Tuple{Any, Any}","page":"Functions","title":"EDDP._apply_embedding_batch","text":"Apply the embedding for an matrix input, the columns are made of vectors  to be embedded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.backprop!-Tuple{EDDP.BodyEmbeddingGradient, EDDP.BodyEmbedding}","page":"Functions","title":"EDDP.backprop!","text":"Perform backpropagation - this requires the forward pass to be run an upstream gradients computed\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.forward!-Tuple{EDDP.BodyEmbeddingGradient, EDDP.BodyEmbedding, Any, Any, Any, Any}","page":"Functions","title":"EDDP.forward!","text":"Forward pass\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.forward!-Tuple{EDDP.CellEmbeddingGradient, EDDP.CellEmbedding, Any, Any, Any, Any}","page":"Functions","title":"EDDP.forward!","text":"Forward pass\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.num_each_feat_elements-Tuple{EDDP.BodyEmbedding}","page":"Functions","title":"EDDP.num_each_feat_elements","text":"Number of elements for each feature\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.num_embed-Tuple{EDDP.BodyEmbedding}","page":"Functions","title":"EDDP.num_embed","text":"Number of embedded vectors\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.num_feat-Tuple{EDDP.BodyEmbedding}","page":"Functions","title":"EDDP.num_feat","text":"Number of feature sets to be compressed\n\n\n\n\n\n","category":"method"},{"location":"functions/#ChainRulesCore.rrule-Tuple{typeof(EDDP._apply_embedding_batch), AbstractMatrix, AbstractMatrix}","page":"Functions","title":"ChainRulesCore.rrule","text":"Custom rule for the applyembedding_batch function\n\n\n\n\n\n","category":"method"},{"location":"functions/#ChainRulesCore.rrule-Tuple{typeof(EDDP._apply_embedding_cell), Any, Any, Any, Any, Any, AbstractMatrix}","page":"Functions","title":"ChainRulesCore.rrule","text":"Custom rule for the applyembedding_cell function\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.CoreReplusion","page":"Functions","title":"EDDP.CoreReplusion","text":"CoreReplusion(rcut)\n\nConstruct a core repulsion with a specific cut off radius.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.core_repulsion-Tuple{Any, Any}","page":"Functions","title":"EDDP.core_repulsion","text":"Core repulsion energy\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.gcore_repulsion-Tuple{Any, Any}","page":"Functions","title":"EDDP.gcore_repulsion","text":"Core repulsion gradient\n\n\n\n\n\n","category":"method"},{"location":"functions/#Training","page":"Functions","title":"Training","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Routines for training models feature vectors ","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"preprocessing.jl\",\n    \"training.jl\",\n    \"lmsolve.jl\",\n    \"nntools.jl\",\n]","category":"page"},{"location":"functions/#EDDP.FeatureContainer","page":"Functions","title":"EDDP.FeatureContainer","text":"FeatureContainer{T,N}\n\nContainer for holding features from structures.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.FeatureContainer-Tuple{StructureContainer, CellFeature}","page":"Functions","title":"EDDP.FeatureContainer","text":"FeatureContainer(sc::StructureContainer, featurespec; nmax=500, kwargs...)\n\nGet a feature container.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.StructureContainer","page":"Functions","title":"EDDP.StructureContainer","text":"StructureContainer{T}\n\nLoader for storing structure data\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.StructureContainer-Tuple{Vector}","page":"Functions","title":"EDDP.StructureContainer","text":"StructureContainer(paths::Vector)\n\nArgs:\n\n- `energy_threshold`: structures with per-atom energy higher than this are excluded. \n  Relative to the median energy.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.split-Tuple{Union{FeatureContainer, StructureContainer}, Vararg}","page":"Functions","title":"Base.split","text":"split(c::Container, n1, n2, ...;shuffle=true)\n\nSplit the container into multiple parts, each with N number of structures. By default, the output container will have their feature vectors standardized.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._idx_group_by_composition-Tuple{Any}","page":"Functions","title":"EDDP._idx_group_by_composition","text":"_idx_group_by_composition(structures)\n\nReturn the index of structures of each unique composition.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._select_per_atom_threshold-Tuple{Any, Any}","page":"Functions","title":"EDDP._select_per_atom_threshold","text":"Return index selected based on per-formula atomic energy\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._split_vector-Tuple{Any, Vararg{Int64}}","page":"Functions","title":"EDDP._split_vector","text":"Split a vector by integer numbres\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_fc-Tuple{Any}","page":"Functions","title":"EDDP.load_fc","text":"load_fc(fname)\n\nLoad FeatureContainer from a file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.reconstruct_x!-Tuple{Any, Any}","page":"Functions","title":"EDDP.reconstruct_x!","text":"Recover training X inputs\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.save_fc-Tuple{Any, Any}","page":"Functions","title":"EDDP.save_fc","text":"save_fc(fc, fname)\n\nSave FeatureContainer into a file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.standardize!-Tuple{Any, Any, Vararg{Any}}","page":"Functions","title":"EDDP.standardize!","text":"standardize!(fc_train, fcs...)\n\nStandardise multiple feature containers. Only the first argument is used for fitting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.standardize!-Tuple{FeatureContainer}","page":"Functions","title":"EDDP.standardize!","text":"standardize!(fc::FeatureContainer)\n\nStandardize the data in the FeatureContainer. The feature vectors are modified. Note that only the input features are fitted and scaled, the outputs are only fitted but the standardisation is not applied.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.standardize-Tuple{Any, Vararg{Any}}","page":"Functions","title":"EDDP.standardize","text":"standardize(fc_train, fcs...)\n\nStandardise multiple feature containers. Only the first argument is used for fitting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.train_test_split-Tuple{Union{FeatureContainer, StructureContainer}}","page":"Functions","title":"EDDP.train_test_split","text":"tain_test_split(v::FeatureContainer; ratio_test=0.1, shuffle=true)\n\nSplit the training \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.transform_x!-Tuple{Any, Any}","page":"Functions","title":"EDDP.transform_x!","text":"Apply transformation for training X inputs\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.TrainingResultsSummary-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.TrainingResultsSummary","text":"TrainingResultsSummary(train, test ,valid)\n\nConstruct a TrainingResultsSummary object from TrainingResults for the train, test and  validation sets.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.getindex-Union{Tuple{T}, Tuple{TrainingResults, Union{UnitRange, Vector{T}}}} where T<:Int64","page":"Functions","title":"Base.getindex","text":"Base.getindex(v::TrainingResults, idx::Union{UnitRange, Vector{T}}) where {T<: Int}\n\nAllow slicing to work on TrainingResults.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.ae_per_atom-Tuple{TrainingResults}","page":"Functions","title":"EDDP.ae_per_atom","text":"Absolute per-atom error\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.boltzmann","page":"Functions","title":"EDDP.boltzmann","text":"boltzmann(x, kT, x0=0.)\n\nComputes the boltzmann distribution: e^frac-(x - x0)kT.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.create_ensemble-Tuple{Any, AbstractVector, AbstractVector}","page":"Functions","title":"EDDP.create_ensemble","text":"create_ensemble(models::AbstractVector, x::AbstractVector, y::AbstractVector;\n\nCreate an EnsembleNNInterface from a vector of interfaces and x, y data for fitting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.create_ensemble-Tuple{Any, FeatureContainer, Vararg{Any}}","page":"Functions","title":"EDDP.create_ensemble","text":"create_ensemble(all_models, fc_train::FeatureContainer, args...)\n\nCreate ensemble model from training data.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.ensemble_std-Union{Tuple{TrainingResults{M, T}}, Tuple{T}, Tuple{M}} where {M, T<:EDDP.EnsembleNNInterface}","page":"Functions","title":"EDDP.ensemble_std","text":"ensemble_std(tr::TrainingResults{M, T};per_atom=true) where {M, T<:EnsembleNNInterface}\n\nReturn the standard deviation from the ensemble for each data point. Defaults to atomic energy.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.generate_chain-Tuple{Any, Any}","page":"Functions","title":"EDDP.generate_chain","text":"Genreate a Chain based on a vector specifying the number of hidden nodes in each layer\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.generate_f_g_optim-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.generate_f_g_optim","text":"generate_f_g_optim_batch(model, train, test)\n\nGenerate f, g!, view of the parameters and the callback function for NN training using Optim.\n\nThis is for 'batch' training where all of the data are included.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.generate_f_g_optim_alt-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.generate_f_g_optim_alt","text":"generate_f_g_optim(model, train, test)\n\nGenerate f, g!, view of the parameters and the callback function for NN training using Optim.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.mae_per_atom-Tuple{EDDP.AbstractNNInterface, Any, Any, Any}","page":"Functions","title":"EDDP.mae_per_atom","text":"mae_per_atom(itf::AbstractNNInterface, x, y, nat)\n\nReturn per-atom-mean absolute error.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.nnls_weights-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.nnls_weights","text":"nnls_weights(models, x, y)\n\nCompute the weights for an ensemble of models using NNLS. Args:     - models: aTuple/Vectorof models.     -x: aVectorcontaining the features of each structure.     -y: aVector` containing the total energy of each structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.r2score_each_comp-Tuple{TrainingResults}","page":"Functions","title":"EDDP.r2score_each_comp","text":"r2score_each_comp(tr::TrainingResults)\n\nCompute the R2 score for each composition separately as it does not make sense to compute  using the full dataset containing different compositions.\n\nSee also: https://scikit-learn.org/stable/modules/model_evaluation.html#r2-score\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.rmse_per_atom-Tuple{EDDP.AbstractNNInterface, Any, Any, Any}","page":"Functions","title":"EDDP.rmse_per_atom","text":"rmse_per_atom(itf::AbstractNNInterface, x, y, nat)\n\nReturn per-atom root-mean square error.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.spearman-Tuple{TrainingResults}","page":"Functions","title":"EDDP.spearman","text":"spearman(tr::TrainingResults)\n\nCompute the average spearman score for each composition. \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.spearman_each_comp-Tuple{TrainingResults}","page":"Functions","title":"EDDP.spearman_each_comp","text":"spearman_each_comp(tr::TrainingResults)\n\nReturn unique reduced formula and their spearman scores. \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.train_lm!-Tuple{EDDP.AbstractNNInterface, Any, Any}","page":"Functions","title":"EDDP.train_lm!","text":"Perform training for the given TrainingConfig\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.worker_train_one-NTuple{5, Any}","page":"Functions","title":"EDDP.worker_train_one","text":"worker_train_one(model, x, y, jobs_channel, results_channel;kwargs...)\n\nTrain one model and put the results into a channel\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.@_itf_per_atom_wrap-Tuple{Any}","page":"Functions","title":"EDDP.@_itf_per_atom_wrap","text":"Allow func(itf, fc) signature to be used....\n\n\n\n\n\n","category":"macro"},{"location":"functions/#EDDP.ATWA!-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.ATWA!","text":"Implement the output of\n\n$ A^T W A $\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.ATWA_DIAG!-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.ATWA_DIAG!","text":"Compute the output of \n\n$ diag(A^T W A) $\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.earlystopcheck-Tuple{Any, Any}","page":"Functions","title":"EDDP.earlystopcheck","text":"Signal stop if the min is more than n cycles away\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._chunk_ranges-Tuple{Any}","page":"Functions","title":"EDDP._chunk_ranges","text":"_chunk_ranges(ndata; ngps=1)\n\nDivide a range into multiple chunks such that each thread receives up to ngps chunks in total.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._collect_gradient!-Tuple{Any, EDDP.CellEmbeddingGradient, Any}","page":"Functions","title":"EDDP._collect_gradient!","text":"_collect_gradient!(gvec, g::CellEmbeddingGradient, i)\n\nCollect gradient from a CellEmbeddingGradient layer\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._collect_gradient!-Tuple{Any, EDDP.DenseGradient, Any}","page":"Functions","title":"EDDP._collect_gradient!","text":"_collect_gradient!(gvec, g::DenseGradient, i)\n\nCollect gradient from a DenseGradient layer\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.atomic_rmse-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.atomic_rmse","text":"atomic_rmse(f, x, y, yt)\n\nCompute per atom based RMSE\n\nArgs:\n\nf: prediction function\nx: input data \ny: reference data \nyt: Normalisation transformation originally applied to obtain y.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.collect_gradients!-Tuple{AbstractVector, EDDP.ChainGradients}","page":"Functions","title":"EDDP.collect_gradients!","text":"collect_gradients!(gvec::AbstractVector, gbuff::ChainGradients)\n\nCollect the gradients after back-propagration into a vector\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.compute_jacobian_backprop!-Tuple{Any, Any, Any, AbstractVector}","page":"Functions","title":"EDDP.compute_jacobian_backprop!","text":"compute_jacobian_backprop!(jacmat, gbuffs, model, data::AbstractVector)\n\nCompute jacobian of the NN weights/bias using back-propagation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.default_rng_value-Tuple{}","page":"Functions","title":"EDDP.default_rng_value","text":"default_rng_value()\n\nCreate an instance of the default RNG depending on Julia's version.\n\nJulia version is < 1.7: Random.GLOBAL_RNG\nJulia version is >= 1.7: Random.default_rng()\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.setup_fg_backprop-Tuple{Any, AbstractVector, Any}","page":"Functions","title":"EDDP.setup_fg_backprop","text":"setup_fg_backprop(model, data::AbstractVector, y)\n\nGet a function for computing both the objective function and the  jacobian matrix for the mean atomic energy.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.setup_fj","page":"Functions","title":"EDDP.setup_fj","text":"setup_fj(model::AbstractNNInterface, data::AbstractVector, y)\n\nSetup the function returning the residual and the jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Model-interfaces","page":"Functions","title":"Model interfaces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"nn/interface.jl\",\n    \"nn/linear.jl\",\n    \"nn/flux.jl\",\n    \"nn/manual_backprop.jl\",\n    \"nn/ensemble.jl\",\n]","category":"page"},{"location":"functions/#EDDP.backward!","page":"Functions","title":"EDDP.backward!","text":"Do the backward step\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.flux_mlp_model-Tuple{CellFeature, Vararg{Any}}","page":"Functions","title":"EDDP.flux_mlp_model","text":"Obtain an baseline MLP model\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.forward!","page":"Functions","title":"EDDP.forward!","text":"Do the forward step\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.gradinp!","page":"Functions","title":"EDDP.gradinp!","text":"Return the gradient of the total energy against the inputs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.gradparam!","page":"Functions","title":"EDDP.gradparam!","text":"Return a vector of the gradients of the total energy against the parameters.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.load_from_jld2-Tuple{AbstractString, Type{<:EDDP.AbstractNNInterface}}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(str::AbstractString, t::Type{<:AbstractNNInterface})\n\nLoad saved interface from JLD2 file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_from_jld2-Tuple{AbstractString}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(str::AbstractString)\n\nLoad saved interface from JLD2 file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_from_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(f)\n\nLoad from JLD2 file/JLD2 group.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.nparams","page":"Functions","title":"EDDP.nparams","text":"Return the number of parameters\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.paramvector","page":"Functions","title":"EDDP.paramvector","text":"Return a vector containing the parameters\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.paramvector!","page":"Functions","title":"EDDP.paramvector!","text":"Return a vector containing the parameters\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.save_as_jld2-Tuple{AbstractString, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.save_as_jld2","text":"save_as_jld2(str::AbstractString, obj::AbstractNNInterface)\n\nSave an trained interface object as JLD2.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.setparamvector!","page":"Functions","title":"EDDP.setparamvector!","text":"Set the parameters with a vector\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.transformed_inp-Tuple{Any, Any}","page":"Functions","title":"EDDP.transformed_inp","text":"Obtain an transformed the input array\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_from_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}, Type{EDDP.LinearInterface}}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(f, obj::LinearInterface)\n\nLoad from JLD2 file/JLD2 group.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.save_as_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}, EDDP.LinearInterface}","page":"Functions","title":"EDDP.save_as_jld2","text":"save_as_jld2(f, obj::LinearInterface)\n\nSave the interface into an opened JLD2 file/JLD2 group.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.FluxInterface","page":"Functions","title":"EDDP.FluxInterface","text":"Standard Flux interface wrapping a model object.\n\nThis interface uses Zygote for AD.  Performance is not ideal for training using the LM method due to the accumulated overheads of calling the gradient function. It should be OK to use for inference (but still inferior compared to ManualFluxBackPropInterface).\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.backward!-Tuple{EDDP.FluxInterface, Vararg{Any}}","page":"Functions","title":"EDDP.backward!","text":"Run the backward step - this creates the pull back functions\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.DenseGradient","page":"Functions","title":"EDDP.DenseGradient","text":"Buffer for storing gradients of a dense network\n\ny = σ.(W * x .+ b)\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.DenseGradient-Tuple{Flux.Dense, Any, Any, Any}","page":"Functions","title":"EDDP.DenseGradient","text":"DenseGradient(dense::Dense, gσ, n)\n\nBuffer for storing gradients of a dense network\n\ny = σ.(W * x .+ b)\n\nArgs:\n\ngσ: the function that computes the local gradient of the activation function.   It must take two arguments x and fx, where fx = σ(x).\nn: size of the batch.\nout: Matrix of the output after this layer\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._get_or_create_chaingradients-Tuple{Any, Any}","page":"Functions","title":"EDDP._get_or_create_chaingradients","text":"Select the ChainGradients with the right size\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.backprop!-Tuple{EDDP.DenseGradient, Flux.Dense}","page":"Functions","title":"EDDP.backprop!","text":"backprop!(dg::DenseGradient, d::Dense;weight_and_bias=true)\n\nCompute the gradients of a dense network based on back-propagation.\n\nArgs:\n\nweight_and_bias: Update the gradients for weight and bias. Defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.backward!-Tuple{EDDP.ChainGradients, Flux.Chain}","page":"Functions","title":"EDDP.backward!","text":"backward!(chaing::ChainGradients, chain::Chain;gu=one(eltype(chain.layers[1].weight)))\n\nBack-propagate the gradients after a forward pass. Args:\n\ngu: is the upstream gradient for the loss of the entire chain. The default is equivalent to: loss = sum(chain(x)), which is a matrix of 1 in the same shape of the output matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.forward!-Tuple{EDDP.ChainGradients, Flux.Chain, Any}","page":"Functions","title":"EDDP.forward!","text":"forward!(chaing::ChainGradients, chain::Chain, x;copy=false)\n\nDo a forward pass compute the intermediate quantities for each layer\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.forward!-Tuple{EDDP.DenseGradient, Flux.Dense, EDDP.DenseGradient, Any, Any, Any}","page":"Functions","title":"EDDP.forward!","text":"Internal per-layer forward pass\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.gradinp!-Tuple{AbstractVecOrMat, EDDP.ManualFluxBackPropInterface}","page":"Functions","title":"EDDP.gradinp!","text":"Return the gradient of the input matrix X against the sum of the output sum(G(X)).\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_from_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}, Type{EDDP.ManualFluxBackPropInterface}}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(f, obj::ManualFluxBackPropInterface)\n\nLoad from JLD2 file/JLD2 group.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.paramvector!-Tuple{AbstractVector, Flux.Chain}","page":"Functions","title":"EDDP.paramvector!","text":"paramvector!(vec, model)\n\nReturn a vector containing all parameters of a model concatenated as a vector\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.save_as_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}, EDDP.ManualFluxBackPropInterface}","page":"Functions","title":"EDDP.save_as_jld2","text":"save_as_jld2(f, obj::ManualFluxBackPropInterface)\n\nSave the interface into an opened JLD2 file/JLD2 group.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.update_param!-Tuple{Any, Any}","page":"Functions","title":"EDDP.update_param!","text":"update_param!(model, param)\n\nUpdate the parameters of a model from a given vector\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.EnsembleNNInterface","page":"Functions","title":"EDDP.EnsembleNNInterface","text":"EnsembleNNInterface{T<:Tuple}\n\nEnsemble of many models\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.load_from_jld2-Tuple{Union{JLD2.Group, JLD2.JLDFile}, Type{<:EDDP.EnsembleNNInterface}}","page":"Functions","title":"EDDP.load_from_jld2","text":"load_from_jld2(f::Union{<:JLD2.Group, <:JLD2.JLDFile}, ::Type{<:EnsembleNNInterface})\n\nLoad from JLD2 file or JLD2 group. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Using-potentials","page":"Functions","title":"Using potentials","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Routines for using the trained potentials for energy/forces/stress calculations.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"calculator.jl\",\n    \"opt.jl\",\n]","category":"page"},{"location":"functions/#EDDP.VariableCellCalc","page":"Functions","title":"EDDP.VariableCellCalc","text":"Filter for including lattice vectors in the optimisation\n\nReference:   E. B. Tadmor, G. S. Smith, N. Bernstein, and E. Kaxiras,             Phys. Rev. B 59, 235 (1999)\n\nBase on ase.constraints.UnitCellFilter\n\n\n\n\n\n","category":"type"},{"location":"functions/#CellBase.get_positions-Tuple{VariableCellCalc}","page":"Functions","title":"CellBase.get_positions","text":"get_positions(cf::VariableCellCalc)\n\nComposed positions vectors including cell defromations\n\n\n\n\n\n","category":"method"},{"location":"functions/#CellBase.set_positions!-Tuple{VariableCellCalc, Any}","page":"Functions","title":"CellBase.set_positions!","text":"Update the positions passing through the filter\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._calculate_two_pass!-Tuple{Any}","page":"Functions","title":"EDDP._calculate_two_pass!","text":"Do a two-pass approach - first pass get the feature vectors and the second  pass will obtain the gradients\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._get_forces_and_stress-Tuple{VariableCellCalc}","page":"Functions","title":"EDDP._get_forces_and_stress","text":"_get_forces_and_stress(cf::VariableCellCalc;rebuild_nl)\n\nConstruct force and stress for the filter object\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._rebuild_on_demand-Tuple{Any}","page":"Functions","title":"EDDP._rebuild_on_demand","text":"Trigger rebuild of the NeighbourList\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.apply_chainrule!-Tuple{Any, Any}","page":"Functions","title":"EDDP.apply_chainrule!","text":"Apply Chain rule to compute forces\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.check_global_minsep-Tuple{NeighbourList, Any}","page":"Functions","title":"EDDP.check_global_minsep","text":" check_global_minsep(nl::NeighbourList, threshold)\n\nCheck if there are atoms that are too close to each other.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.copycell!-Tuple{Cell, Cell}","page":"Functions","title":"EDDP.copycell!","text":"Copy the lattice and positions from one cell to the other\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy-Tuple{Cell, CellFeature, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.get_energy","text":"get_energy(cell::Cell, cf::CellFeature, itf::AbstractNNInterface;kwargs...)\n\nConvenient method for calling get_energy with a Calculator constructed ad-hoc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy-Tuple{NNCalc}","page":"Functions","title":"EDDP.get_energy","text":"get_energy(calc::NNCalc; forces=false, rebuild_nl=true)\n\nReturn the total energy of the calculator.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy_std-Tuple{Cell, CellFeature, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.get_energy_std","text":"get_energy_std(cell::Cell, cf::CellFeature, itf::AbstractNNInterface;kwargs...)\n\nConvenient method for calling getenergystd with a Calculator constructed ad-hoc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy_std-Union{Tuple{NNCalc{T, N, M, X}}, Tuple{X}, Tuple{M}, Tuple{N}, Tuple{T}} where {T, N, M, X<:EDDP.EnsembleNNInterface}","page":"Functions","title":"EDDP.get_energy_std","text":"Return standard deviation of the predicted total energy Note: must be run after a energy call!\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_enthalpy-Tuple{Cell, CellFeature, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.get_enthalpy","text":"get_enthalpy(cell::Cell, cf::CellFeature, itf::AbstractNNInterface;kwargs...)\n\nConvenient method for calling get_enthalpy with a Calculator constructed ad-hoc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_forces-Tuple{Cell, CellFeature, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.get_forces","text":"get_forces(cell::Cell, cf::CellFeature, itf::AbstractNNInterface;kwargs...)\n\nConvenient method for calling get_forces with a Calculator constructed ad-hoc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_forces-Tuple{VariableCellCalc}","page":"Functions","title":"EDDP.get_forces","text":"Forces including the stress contributions that is consistent with the augmented positions\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_pressure-Tuple{Cell, CellFeature, EDDP.AbstractNNInterface}","page":"Functions","title":"EDDP.get_pressure","text":"get_pressure(cell::Cell, cf::CellFeature, itf::AbstractNNInterface;kwargs...)\n\nConvenient method for calling get_pressure with a Calculator constructed ad-hoc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_pressure-Tuple{EDDP.AbstractCalc}","page":"Functions","title":"EDDP.get_pressure","text":"get_pressure(calc::VariableCellCalc)\n\nReturn the total pressure with the external pressure subtracted.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_pressure_gpa-Tuple{EDDP.AbstractCalc}","page":"Functions","title":"EDDP.get_pressure_gpa","text":"get_pressure_gpa(vc::AbstractCalc)\n\nReturn pressure in unit of GPa.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_stress-Tuple{VariableCellCalc}","page":"Functions","title":"EDDP.get_stress","text":"get_stress(vc::VariableCellCalc;kwargs...)\n\nReturn the effective stress of the VaraibleCellCalc (including the external pressure)\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.is_equal-Tuple{Any, Any}","page":"Functions","title":"EDDP.is_equal","text":"is_equal(cell_a, cell_b)\n\nCheck if two cells are equal to each other\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.update_feature_vector!-Tuple{NNCalc}","page":"Functions","title":"EDDP.update_feature_vector!","text":"update_feature_vector!(calc::NNCalc; rebuild_nl=true, gradients=true, global_minsep=0.01, maxvol=100, gv_offset=0)\n\nReturns the updated the feature vectors after atomic displacements\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.opt_tpsd-Tuple{EDDP.AbstractCalc}","page":"Functions","title":"EDDP.opt_tpsd","text":"opt_tpsd(vc::AbstractCalc; f_tol=1e-3, s_tol=1e-3, e_tol=1e-5, \n              itermax=1000, trace=false, α_tol=1e-10, callback=nothing, \n              trajectory=nothing)\n\nOptimise a structure (calculation) using TPSD. Reference:     - Barzilai, J. and Borwein, J.M., 1988. Two-point step size gradient methods. IMA journal of numerical analysis, 8(1), pp.141-148\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-tools","page":"Functions","title":"Miscellaneous tools","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Support utilities and tools.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"tools.jl\",\n    \"records.jl\",\n    \"plotting/recipes.jl\",\n    \"eddpf90.jl\",\n]","category":"page"},{"location":"functions/#CellBase.write_res-Tuple{Any, VariableCellCalc}","page":"Functions","title":"CellBase.write_res","text":"write_res(path, vc::VariableCellCalc;symprec=1e-2, label=\"EDDP\")\n\nWrite structure in VariableCellCalc as SHELX file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.is_unique_fvec-Tuple{Any, Any}","page":"Functions","title":"EDDP.is_unique_fvec","text":"Check if a feature vector already present in an array of vectors\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.stem-Tuple{AbstractString}","page":"Functions","title":"EDDP.stem","text":"Return the stea part of a file name\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.update_metadata!-Tuple{EDDP.AbstractCalc, Any}","page":"Functions","title":"EDDP.update_metadata!","text":"update_metadata!(vc::AbstractCalc, label;symprec=1e-2)\n\nUpdate the metadata attached to a Cell` object\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.AbstractRecord","page":"Functions","title":"EDDP.AbstractRecord","text":"Abstract record that can be used to construct a phase diagram\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.PhaseDiagram-Tuple{StructureContainer}","page":"Functions","title":"EDDP.PhaseDiagram","text":"PhaseDiagram(sc::StructureContainer)\n\nConstruct a PhaseDiagram object from a StructureContainer.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.PhaseDiagram-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}} where T<:EDDP.AbstractRecord","page":"Functions","title":"EDDP.PhaseDiagram","text":"PhaseDiagram(records::Vector{T})\n\nConstruct a PhaseDiagram from a vector of AbstractRecord. Args:\n\nelements: A vector of symbols for enforcing a specific ordering of the elements.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.Simplex","page":"Functions","title":"EDDP.Simplex","text":"Type that represents a simplex in N-dimensional space\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.Simplex-Tuple{Any}","page":"Functions","title":"EDDP.Simplex","text":"Simplex(coords)\n\nConstruct a simplex from a matrix of the coordinates\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._formation_energies-Tuple{Any, Any}","page":"Functions","title":"EDDP._formation_energies","text":"_formation_energies(records, elemental_forms)\n\nReturn the formation energy per atom.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.bary_coords-Tuple{EDDP.Simplex, Vector}","page":"Functions","title":"EDDP.bary_coords","text":"bary_coords(s::Simplex, point::Vector)\n\nObtain barycentric coordinates for a given point\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.contains_point","page":"Functions","title":"EDDP.contains_point","text":"contains_point(s::Simplex, point::Vector, tol=1e-8)\n\nCheck if a Simplex contains the given point.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.coords_from_bary-Tuple{EDDP.Simplex, Vector}","page":"Functions","title":"EDDP.coords_from_bary","text":"Convert barycentric coordinate to normal point\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_2d_plot_data-Tuple{PhaseDiagram}","page":"Functions","title":"EDDP.get_2d_plot_data","text":"Return data needed for constructing a 2D convex hull diagram\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_composition_coord-Tuple{Any, Any}","page":"Functions","title":"EDDP.get_composition_coord","text":"get_composition_coord(comp, elements)\n\nReturn the composition coordinates\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_coord-Tuple{Composition, Vector{Symbol}}","page":"Functions","title":"EDDP.get_coord","text":"get_coord(comp, elements)\n\nReturn the composition coordination for a given composition.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_decomposition-Tuple{Any, Any}","page":"Functions","title":"EDDP.get_decomposition","text":"get_decomposition(phased, record)\n\nReturn the decomposition of a record\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_ternary_hulldata-Tuple{PhaseDiagram}","page":"Functions","title":"EDDP.get_ternary_hulldata","text":"get_ternary_hulldata(phased::PhaseDiagram)\n\nReturn the ternary coordinates for all stable and non stable phases \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._get_rel_target_and_pred-Tuple{TrainingResults}","page":"Functions","title":"EDDP._get_rel_target_and_pred","text":"Return relative per-atom energies\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.enthalpyandvolume","page":"Functions","title":"EDDP.enthalpyandvolume","text":"enthalpyandvolume(args...;kwargs...)\n\nPlots the training/predicted enthalpy per atom verses the volume per atom. If the first argument is a TrainingResults then the predicted enthalpies will be used instead.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.inoutsample","page":"Functions","title":"EDDP.inoutsample","text":"inoutsample(builder::Builder, i::Int)\n\nReturn plots for out-of-sample prediction analysis. This function loads the model trained up to i iteration and apply it to the i + 1 iteration. The prediction results is hence effectively \"out-of-sample\".\n\nIdeally, we want the out-of-sample to behave like the in-sample results. Unless otherwise stateed, latter refers to the training data and the model at the i iteration.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.relativeabsoluteerror","page":"Functions","title":"EDDP.relativeabsoluteerror","text":"relativeabsoluteerror(t::TrainingResults, args...;kwargs...)\n\nPlot the absolute error per atom against the relative energy (per atom). This can be useful to check that the those with lower energy has smaller errors.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.write_eddpf90_features-Tuple{FeatureContainer, Any}","page":"Functions","title":"EDDP.write_eddpf90_features","text":"Write the feature vectors\n\n\n\n\n\n","category":"method"},{"location":"functions/#Automated-potentials-building","page":"Functions","title":"Automated potentials building","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function for providing automatic iterative potential building via random structure structure searching.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP]\nPages = [\n    \"link/link.jl\",\n    \"link/trainer.jl\",\n]","category":"page"},{"location":"functions/#EDDP.Builder","page":"Functions","title":"EDDP.Builder","text":"Builder(str::AbstractString=\"link.toml\")\n\nLoad the builder from a YAML file. The file contains nested key-values pairs similar to the constructors of the types.\n\nstate:\n    seedfile : \"test.cell\"\n\ntrainer:\n    type : \"locallm\"\n    nmodels : 128\ncf:\n    elements : [\"H\", \"O\"]\n    # Power of the polynomials as geometry sequence \n    p2       : [2, 10, 5] \n    geometry_sequence : true\n\ncf_embedding:\n    n : 3\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.Builder-2","page":"Functions","title":"EDDP.Builder","text":"The Builder stores states and options for training and using the potentials.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP._call_pp3-Tuple{Any}","page":"Functions","title":"EDDP._call_pp3","text":"_call_pp3(aname)\n\nCall pp3 to calculate the energy/pressure of a seed file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._disp_get_completed_jobs-Tuple{Any}","page":"Functions","title":"EDDP._disp_get_completed_jobs","text":"_disp_get_completed_jobs(project_name)\n\nGet the number of completed jobs as well as the total number of jobs under a certain project. NOTE: this requires disp to be available in the commandline.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._generate_random_structures-Tuple{Builder, Any}","page":"Functions","title":"EDDP._generate_random_structures","text":"_generate_random_structures(bu::Builder, iter)\n\nGenerate random structure (if needed) as training data for the Builder.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._input_structure_dir-Tuple{Builder}","page":"Functions","title":"EDDP._input_structure_dir","text":"Directory for input structures\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._make_symbol_keys-Tuple{Dict}","page":"Functions","title":"EDDP._make_symbol_keys","text":"_make_symbol_keys(dict::Dict)\n\nSwap the String keys of a dictonary into Symbol.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._output_structure_dir-Tuple{Builder}","page":"Functions","title":"EDDP._output_structure_dir","text":"Directory for output structures after external calculations\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._perform_training_external-Tuple{Builder}","page":"Functions","title":"EDDP._perform_training_external","text":"Carry out training and save the ensemble as a JLD2 archive.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._run_external-Tuple{Builder}","page":"Functions","title":"EDDP._run_external","text":"Run external code for generating training data\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._run_rss_link-Tuple{}","page":"Functions","title":"EDDP._run_rss_link","text":"_run_rss_link()\n\nRun the random search step as part of the link! iterative building protocol. This function is intented to be called as a separated Julia process.\n\nnote: Note\nThis function is meanted to be called with commandline arguments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP._set_iteration!-Tuple{Builder}","page":"Functions","title":"EDDP._set_iteration!","text":"_set_iteration!(builder::Builder)\n\nFastword to the iteration by checking existing ensemble files\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy-Tuple{Cell, Builder, Int64}","page":"Functions","title":"EDDP.get_energy","text":"get_energy(cell::Cell, builder::Builder, gen::Int=_latest_ensemble_iteration(builder);kwargs...)\n\nConvenient method for calling get_energy using a Builder object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_energy_std-Tuple{Cell, Builder, Int64}","page":"Functions","title":"EDDP.get_energy_std","text":"get_energy_std(cell::Cell, builder::Builder, gen::Int=_latest_ensemble_iteration(builder);kwargs...)\n\nConvenient method for calling getenergystd using a Builder object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_enthalpy-Tuple{Cell, Builder, Int64}","page":"Functions","title":"EDDP.get_enthalpy","text":"get_enthalpy(cell::Cell, builder::Builder, gen::Int=_latest_ensemble_iteration(builder);kwargs...)\n\nConvenient method for calling get_enthalpy using a Builder object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_forces-Tuple{Cell, Builder, Int64}","page":"Functions","title":"EDDP.get_forces","text":"get_forces(cell::Cell, builder::Builder, gen::Int=_latest_ensemble_iteration(builder);kwargs...)\n\nConvenient method for calling get_forces using a Builder object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.get_pressure-Tuple{Cell, Builder, Int64}","page":"Functions","title":"EDDP.get_pressure","text":"get_pressure(cell::Cell, builder::Builder, gen::Int=_latest_ensemble_iteration(builder);kwargs...)\n\nConvenient method for calling get_pressure using a Builder object.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.link!-Tuple{Builder}","page":"Functions","title":"EDDP.link!","text":"link!(builder::Builder)\n\nRun automated iterative building cycles.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.link-Tuple{}","page":"Functions","title":"EDDP.link","text":"link()\n\nRun link! from command line interface.\n\nExample: \n\njulia -e \"Using EDDP;EDDP.link()\" -- --file \"link.toml\" \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.load_features-Tuple{Builder, Vararg{Int64}}","page":"Functions","title":"EDDP.load_features","text":"load_features(bu::Builder, iteration...)\n\nLoading features for specific iterations.   \n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.parse_disp_output-Tuple{Any}","page":"Functions","title":"EDDP.parse_disp_output","text":"parse_disp_output(json_string)\n\nParse the output of disp db summary\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.run_disp_castep-Tuple{Any, Any, Any}","page":"Functions","title":"EDDP.run_disp_castep","text":"Run relaxation through DISP\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.run_pp3","page":"Functions","title":"EDDP.run_pp3","text":"run_pp3(file, seedfile, outpath)\n\nUse pp3 for single point calculations.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.run_pp3_many-NTuple{4, Any}","page":"Functions","title":"EDDP.run_pp3_many","text":"run_pp3_many(workdir, indir, outdir, seedfile; n_parallel=1, keep=false)\n\nUse PP3 for singlepoint calculation - launch many calculations in parallel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.run_rss","page":"Functions","title":"EDDP.run_rss","text":"run_rss(str::AbstractString)\n\nRun random structure searching for a configuration file for the builder.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.run_rss-Tuple{Builder}","page":"Functions","title":"EDDP.run_rss","text":"run_rss(builder::Builder)\n\nRun random structures search using trained ensembel model. The output files are in the  search subfolder by default.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.save_builder-Tuple{AbstractString, Builder}","page":"Functions","title":"EDDP.save_builder","text":"save_builder(fname::AbstractString, builder)\n\nSave a Builder to a file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.step!-Tuple{Builder}","page":"Functions","title":"EDDP.step!","text":"Run a step step for the Builder\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.summarise-Tuple{Builder}","page":"Functions","title":"EDDP.summarise","text":"Summarise the status of the project\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.create_ensemble","page":"Functions","title":"EDDP.create_ensemble","text":"create_ensemble(bu::Builder, tra::TrainingOption=bu.trainer;save_and_clean=false, kwargs...)\n\nCreate ensemble from resulted models. Optionally save the created ensemble model and clear the transient data.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.dataset_name","page":"Functions","title":"EDDP.dataset_name","text":"dataset_name(bu::Builder, i=bu.state.iteration)\n\nFull path to the dataset file.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.load_training_dataset","page":"Functions","title":"EDDP.load_training_dataset","text":"load_training_dataset(bu::Builder, iter=bu.state.iteration;combined=false)\n\nLoad dataset saved for training\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.num_existing_models","page":"Functions","title":"EDDP.num_existing_models","text":"num_existing_models(bu::Builder, tra::TrainingOption=bu.trainer)\n\nReturn the number of existing models in the training directory.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.run_trainer","page":"Functions","title":"EDDP.run_trainer","text":"run_trainer(trainer::TrainingOption, builder::Builder)\n\nTrain the model and write the result to the disk as a JLD2 archive.\n\n\n\n\n\n","category":"function"},{"location":"functions/#EDDP.run_trainer-Tuple{}","page":"Functions","title":"EDDP.run_trainer","text":"run_trainer()\n\nRun training through a command line interface.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.write_dataset","page":"Functions","title":"EDDP.write_dataset","text":"write_dataset(builder)\n\nWrite the dataset to the disk. These are large JLD2 archive containing the data for training, testing and validation\n\n\n\n\n\n","category":"function"},{"location":"functions/#None-negative-least-square-routines","page":"Functions","title":"None-negative least square routines","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Internal routines in the NNLS.jl package embedded in the package.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [EDDP.NNLS]","category":"page"},{"location":"functions/#EDDP.NNLS","page":"Functions","title":"EDDP.NNLS","text":"NNLS copied from NNLS.jl\n\nRemove the code for the solver interface for reduced dependencies. Original code base: https://github.com/rdeits/NNLS.jl\n\n\n\n\n\n","category":"module"},{"location":"functions/#EDDP.NNLS.QP","page":"Functions","title":"EDDP.NNLS.QP","text":"QP{T}\n\nStructure describing the QP: Minimize frac12 z Q z + c z Subject to G z leq g\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.NNLS.QPWorkspace-Union{Tuple{EDDP.NNLS.QP{T}}, Tuple{T}} where T","page":"Functions","title":"EDDP.NNLS.QPWorkspace","text":"QPWorkspace(qp::QP)\n\nConstruct a workspace and load problem data for the QP Minimize frac12 z Q z + c z Subject to G z leq g\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.UnsafeVectorView","page":"Functions","title":"EDDP.NNLS.UnsafeVectorView","text":"UnsafeVectorView\n\nViews in Julia still allocate some memory (since they need to keep a reference to the original array). This type allocates no memory and does no bounds checking. Use it with caution.\n\n\n\n\n\n","category":"type"},{"location":"functions/#EDDP.NNLS.apply_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, T, AbstractVector{T}}} where T","page":"Functions","title":"EDDP.NNLS.apply_householder!","text":"apply_householder!(u::AbstractVector{T}, up::T, c::AbstractVector{T}) where {T}\n\nCONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.check_optimality_conditions-Tuple{EDDP.NNLS.QP, Any, Any}","page":"Functions","title":"EDDP.NNLS.check_optimality_conditions","text":"check_optimality_conditions(qp::QP, z, λ)\n\nProvies a scalar indicator of the violation of the KKT optimality conditions for a given QP, primal solution z, and dual solution λ. A feasible & optimal solution should return a value close to 0, while an infeasible or suboptimal solution should return a value greater than zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.construct_householder!-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T","page":"Functions","title":"EDDP.NNLS.construct_householder!","text":"construct_householder!(u::AbstractVector{T}, up::T)::T where {T}\n\nCONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.dual_infeasibility-Tuple{EDDP.NNLS.QP, Any, Any}","page":"Functions","title":"EDDP.NNLS.dual_infeasibility","text":"dual_infeasibility(qp::QP, λ)\n\nMeasure of primal infeasibility of the solution to the QP Minimize frac12 z Q z + c z Subject to G z leq g wherezis the primal solution andλ`` is the dual solution. For a dual-feasible solution, this will return a value <= 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.fastview-Tuple{AbstractArray, Integer, Integer}","page":"Functions","title":"EDDP.NNLS.fastview","text":"fastview(parent::AbstractArray, start_ind::Integer, len::Integer) =\n\nFallback for non-contiguous arrays, for which UnsafeVectorView does not make sense.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.fastview-Union{Tuple{T}, Tuple{Array{T}, Integer, Integer}} where T","page":"Functions","title":"EDDP.NNLS.fastview","text":"fastview(parent::Array{T}, start_ind::Integer, len::Integer) where {T}\n\nUnsafeVectorView only works for isbitstype types. For other types, we're already allocating lots of memory elsewhere, so creating a new View is fine. This function looks type-unstable, but the isbitstype(T) test can be evaluated by the compiler, so the result is actually type-stable.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.load!-Union{Tuple{T}, Tuple{EDDP.NNLS.QPWorkspace{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}}} where T","page":"Functions","title":"EDDP.NNLS.load!","text":"load!(work::QPWorkspace, Q, c, G, g)\n\nLoad problem data for the QP Minimize frac12 z Q z + c z Subject to G z leq g\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.orthogonal_rotmat-Union{Tuple{T}, Tuple{T, T}} where T","page":"Functions","title":"EDDP.NNLS.orthogonal_rotmat","text":"orthogonal_rotmat(a::T, b::T)::Tuple{T,T,T} where {T}\n\nCOMPUTE ORTHOGONAL ROTATION MATRIX.. The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 12, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.    COMPUTE.. MATRIX   (C, S) SO THAT (C, S)(A) = (SQRT(A2+B2))                       (-S,C)         (-S,C)(B)   (   0          )    COMPUTE SIG = SQRT(A2+B2)       SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT       SIG MAY BE IN THE SAME LOCATION AS A OR B .\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.primal_infeasibility-Tuple{EDDP.NNLS.QP, Any, Any}","page":"Functions","title":"EDDP.NNLS.primal_infeasibility","text":"primal_infeasibility(qp::QP, z)\n\nMeasure of primal infeasibility of the solution to the QP Minimize frac12 z Q z + c z Subject to G z leq g wherezis the primal solution andλ`` is the dual solution. For a primal-feasible solution, this will return a value <= 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.slackness_violation-Tuple{EDDP.NNLS.QP, Any, Any}","page":"Functions","title":"EDDP.NNLS.slackness_violation","text":"slackness_violation(qp::QP, z, λ)\n\nMeasure of the violation of the complementary slackness condition for the QP. For an optimal solution, this should return a value near 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.solve!-Union{Tuple{EDDP.NNLS.NNLSWorkspace{T, TI}}, Tuple{TI}, Tuple{T}, Tuple{EDDP.NNLS.NNLSWorkspace{T, TI}, Integer}} where {T, TI}","page":"Functions","title":"EDDP.NNLS.solve!","text":"solve!(work::NNLSWorkspace{T,TI}, max_iter::Integer=(3 * size(work.QA, 2)))\n\nAlgorithm NNLS: NONNEGATIVE LEAST SQUARES The original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM. GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B,  COMPUTE AN N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM                  A * X = B  SUBJECT TO X .GE. 0\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.solve!-Union{Tuple{EDDP.NNLS.QPWorkspace{T}}, Tuple{T}, Tuple{EDDP.NNLS.QPWorkspace{T}, Any}} where T<:Union{Float32, Float64, ComplexF32, ComplexF64}","page":"Functions","title":"EDDP.NNLS.solve!","text":"z, λ = solve!(work::QPWorkspace)\n\nSolve the QP that was loaded into work using load!. Returns the primal solution z and the dual solution λ.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.solve_triangular_system!-NTuple{5, Any}","page":"Functions","title":"EDDP.NNLS.solve_triangular_system!","text":"solve_triangular_system!(zz, A, idx, nsetp, jj)\n\nThe original version of this code was developed by Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 1973 JUN 15, and published in the book \"SOLVING LEAST SQUARES PROBLEMS\", Prentice-HalL, 1974. Revised FEB 1995 to accompany reprinting of the book by SIAM.\n\n\n\n\n\n","category":"method"},{"location":"functions/#EDDP.NNLS.stationarity_violation-Tuple{EDDP.NNLS.QP, Any, Any}","page":"Functions","title":"EDDP.NNLS.stationarity_violation","text":"stationarity_violation(qp::QP, z, λ)\n\nMeasure of the violation of the stationarity KKT condition for the QP. For an optimal solution, this should return a value near 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"python_tools/#Using-Python-tools","page":"Python Tools","title":"Using Python tools","text":"","category":"section"},{"location":"python_tools/#Setting-up-PyCall.jl","page":"Python Tools","title":"Setting up PyCall.jl","text":"","category":"section"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"PyCall.jl is used to call python funcition define the classes that can use the trained models are calculator. ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Guides for setting it up can be found at its home page. On Linux, this is as simple as (from scratch): ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"conda create -n pycall_env python ase phonopy <other packages2> <other package2> ...\nconda activate pycall\nexport PYTHON=`which python`\njulia -e 'using Pkg; Pkg.add(\"PyCall\"); Pkg.build(\"PyCall\")'\nunset PYTHON","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"The key is to build the PyCall.jl package with a PYTHON environmental variable that points to the interpreter of the virtual environment to be used for Julia. ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"You can verify if the environment is up and running by importing ase in the Julia REPL:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> using PyCall\n\njulia> pyimport(\"ase\")\n","category":"page"},{"location":"python_tools/#Phonon-calculations","page":"Python Tools","title":"Phonon calculations","text":"","category":"section"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Phonon calculations requires a fully relaxed structures, so one has to relax the structure first:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> builder = Builder(\"link.toml\")  # Load the train model\n\njulia> @show builder.state.iteration  # Check if the latest iteration has been detected\n\njulia> res = read_res(\"<path to SHLEX file>\")  # Read in the structure file\n\njulia> calc = NNCalc(res, builder.cf, load_ensemble(builder))   # Construct a NNCalc object\n\njulia> EDDP.optimise!(calc |> VariableCellCalc)   # Optimise with variable cell shape","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Finally, we run the finite displacement calculations:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> using EDDPTools\n\njulia> EDDPTools.run_phonon(calc;outdir=\"phonon\")","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"This writes the YAML files and FORCE_SETS and phonopy_params.yaml files into a new folder called phonon. One can use phonopy for further processing from this point.","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"note: Note\nThe sumo package provides a sumo-phonon-bandplot command which can be used to run a band structure calculation using phonopy with automatically generated band pathways. ","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-potential-for-carbon","page":"Getting Started","title":"A potential for carbon","text":"","category":"section"},{"location":"getting_started/#Metrics","page":"Getting Started","title":"Metrics","text":"","category":"section"},{"location":"getting_started/#Properties","page":"Getting Started","title":"Properties","text":"","category":"section"},{"location":"#EDDP.jl","page":"Home","title":"EDDP.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package that implements the Ephemeral data derived potentials (EDDP). EDDP can be seen as a kind of Machine Learning (Interatomic) Potentials (MLP).  Normally such potentials are aim at accurately reproduce the results of first-principles calculations within a certain region of the configuration space. Once trained, such potentials can be used to run large scale molecular dynamics simulation which are otherwise intractable with first-principles calculations. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDDP takes a simple and physically motivated form that resembles a generalized N-body Lenard-Jones-like potential. While not its originally design goal, EDDP can still give sufficiently accurate forces to allow molecular dynamics simulation (which does not blow-up) and phonon properties for certain systems.  In comparison, other state-of-the art MLPs often requires  description of the local atomic environment and complex gaussian process/deep learning/(graph) neutron network architectures. The hope is being physically sounds allows EDDP to give sufficiently good representations for most of the configuration space, and hence enables one to carry out crystal structure prediction with much reduced computational and time resources.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generating EDDP feature vectors (local descriptors).\nTrain EDDP ensemble models.\nPerform geometry optimization using trained models. \nInterface to other package for property calculations.\nWorkflow script for automated potential building and crystal structure prediction.\nPlot and data analysis for the training dataset and the potentials.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"airss - ab initio random structure (AIRSS) is used for building random structure through the buildcell program included in the bundle.\nCASTEP - A plane-wave DFT code used for efficient generation of  training datasets. \neddp - The Fortran EDDP code. EDDP.jl provides limited interoperability with the eddp fortran package. While it is not possible to use the model trained by one with the other, the training datasets are compatible as both use the AIRSS-style SHELX format.\ndisp - Distributed structure prediction (DISP) is used to schedule and run data generation workloads on (multiple) remote computing clusters. ","category":"page"},{"location":"#Documentations","page":"Home","title":"Documentations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"getting_started.md\", \"faq.md\", \"python_tools.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EDDP","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#Building-custom-system-image","page":"FAQ","title":"Building custom system image","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"At the time of writing, loading Julia modules comes with high latency in addition to the the so called time-to-first-X (TTTX) delay related to time spent on compiling native code in each fresh Julia session.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Such delays can be completely eliminated by compiling a system image using the PackageCompiler.jl, which contain EDDP.jl, EDDPTools.jl and all its dependencies.  This can be done by simply following the documentation of the PackageCompiler.jl ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For development environment this is a bit more complicated while the inconvenience of compiler latency is more pronounce due to frequent session restarts. In this case, a special system image needs to be created that includes all dependencies of EDDP.jl and EDDPTools.jl, plus some commonly used tools (such as BenchmarkTools.jl and Revise), but not EDDP.jl and EDDPTools.jl themselves.  Create such system image, there is a sysimg.jl under the scripts folder that can used via:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia --project=<some project with PackageCompiler installed> -e 'include(\"sysimg.jl\");build()' ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This creates the system image file at ~/.julia/eddpdev.so. To launch julia with the system image:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia -J ~/.julia/eddpdev.so","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> \"Flux\" in [x.name for x in keys(Base.loaded_modules)]\ntrue","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"One should note that any packages compiled into the system image is essentially frozen-in - their version cannot be changed by Pkg. Hence, the system image must be rebuilt after any update of the Manifest.toml.","category":"page"}]
}
